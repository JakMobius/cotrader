import pprint
from abc import ABC
from collections import deque
from pathlib import Path
from typing import Callable

import hydra
import torch

from cotrader.datasource.candles.candle_datasource import Candle, Multicandle
from cotrader.datasource.candles.dummy_datasource import DummyDatasource
from cotrader.datasource.candles.indicators_datasource import IndicatorsDatasource
from cotrader.datasource.candles.list_datasource import ListDatasource
from cotrader.datasource.tensor.candle_dataset import (
    CandleDataset,
    WrappedCandleDatasource,
)
from cotrader.utils.utils import interval_to_ms


class CostPredictor(ABC):
    def __init__(self, cfg, model=None, model_path=None):
        self.window = deque()
        self.cfg = cfg

        self.datasource = IndicatorsDatasource.load(
            ListDatasource(self.window), self.cfg.data.indicators
        )

        self.input_features = CandleDataset.build_features(self.cfg.data.input_features)
        self.output_features = CandleDataset.build_features(
            self.cfg.data.output_features
        )
        self.prediction_features = CandleDataset.build_features(
            self.cfg.data.prediction
        )

        if model is None:
            model = hydra.utils.instantiate(
                self.cfg.model,
                input_features=sum(f.get_feature_count() for f in self.input_features),
                output_features=sum(
                    f.get_feature_count() for f in self.output_features
                ),
            )

            if model_path is None:
                model_path = Path(self.cfg.output.model_file) / "model.pt"
            model.load(model_path)

        self.model = model
        self.window_size = self.get_required_window()

        self.sanity_check()

    def get_predictor_lookbehind(self) -> int:
        return (
            max([feature.get_lookbehind() for feature in self.prediction_features]) - 1
        )

    def get_required_window(self) -> int:
        return self.get_predictor_lookbehind()

    def push_candle(self, candle: Candle):
        pass

    def get_prediction(self, interval: str) -> Candle:
        raise NotImplementedError()

    def push_state(self):
        pass

    def pop_state(self):
        pass

    def sanity_check(self):
        """
        Validates that the target features generated by the dataset closely match
        the actual candle data.

        This method creates a dummy dataset using predefined parameters and
        iterates through its samples. For each sample, it compares the real
        candle values with those extracted from the target features (predicted
        candle) for the properties: 'open', 'high', 'low', 'close', and
        'volume'. If any property differs by more than a small relative
        tolerance (1e-3), a ValueError is raised, indicating a mismatch.

        Raises:
            ValueError: If any candle property in the predicted target features
            deviates significantly from the real value.
        """

        dataset_params = {
            "symbol": "DUMMY",
            "interval": "1m",
            "start_time": 0,
            "end_time": 100 * 60 * 1000,
        }
        datasource = IndicatorsDatasource.load(
            DummyDatasource.get_instance(), self.cfg.data.indicators
        )
        wrapped_datasource = WrappedCandleDatasource(
            datasource=datasource, **dataset_params
        )
        candles = list(wrapped_datasource.get_candles())
        dataset = CandleDataset(
            datasources=[wrapped_datasource],
            sequence_length=1,
            input_features_config=self.cfg.data.input_features,
            output_features_config=self.cfg.data.output_features,
        )

        for i, elt in enumerate(dataset):
            if i >= len(candles):
                break
            x, y, idx, timestamp = elt

            assert i == idx, f"{i} != {idx}"
            assert timestamp == candles[i].timestamp

            def window_accessor(idx):
                return Multicandle(candle=candles[idx + i + 1])

            real_candle = candles[i + 1]
            predicted_candle = self.extract_single_prediction(
                window_accessor, y[-1:, :], "1m"
            )

            for prop in ["open", "high", "low", "close", "volume"]:
                real_value = real_candle.get(prop)
                predicted_value = predicted_candle.get(prop)
                if abs(real_value - predicted_value) > 1e-3 * max(abs(real_value), 1.0):
                    error = (
                        f"Sanity check failed for candles[{i + 1}].'{prop}': "
                        f"real={real_value}, predicted={predicted_value}"
                    )

                    print(error)
                    print("Current candle:", pprint.pformat(real_candle.__dict__))
                    print("Output features:", pprint.pformat(y))
                    print("Previous candle:", pprint.pformat(candles[i].__dict__))
                    print("Output features:", pprint.pformat(dataset[i][1]))

                    raise ValueError(error)

    def extract_single_prediction(
        self,
        window_accessor: Callable[[int], Multicandle],
        prediction: torch.Tensor,
        interval: str,
    ) -> Candle:
        result = Multicandle(size=1)
        result.set("open", torch.tensor([[-1.0]]))
        result.set("high", torch.tensor([[-1.0]]))
        result.set("low", torch.tensor([[-1.0]]))
        result.set("close", torch.tensor([[-1.0]]))
        result.set("volume", torch.tensor([[-1.0]]))

        self.extract_candle_from_prediction(
            window_accessor, result, prediction, interval
        )

        for prop in ["open", "high", "low", "close", "volume"]:
            if result.get(prop) == -1:
                raise ValueError(
                    f"Missing or invalid value for '{prop}' in result candle."
                )

        return result[0]

    def extract_candle_from_prediction(
        self,
        window_accessor: Callable[[int], Multicandle],
        target: Multicandle,
        prediction: torch.Tensor,
        interval: str,
    ):
        def candle_getter(idx):
            if idx == 0:
                return target
            return window_accessor(idx)

        lastCandle = candle_getter(-1)

        interval_ms = interval_to_ms(interval)
        target.timestamp = lastCandle.timestamp + interval_ms

        # extract the feature values into tmp indicators
        value_idx = 0
        for feature in self.output_features:
            feature_length = feature.get_feature_count()
            if feature.target:
                target.set(
                    feature.target,
                    prediction[..., value_idx : value_idx + feature_length].to("cpu"),
                )
            value_idx += feature_length

        # calculate the actual candle

        for feature in self.prediction_features:
            if feature.target is None:
                print(
                    f"Warning: Feature {feature} has no target and will not be set "
                    "in the result candle."
                )
                continue
            target.set(feature.target, feature.flatten(candle_getter))

        return target

    def set_window(self, window: deque):
        self.set_window(window)
        self.datasource.interface = ListDatasource(window)
